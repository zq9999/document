基数（Cardinality）
某个列唯一键（Distinct_Keys）的数量叫作基数。比如性别列，该列只有男女之分，所以这一列基数是2。
主键列的基数等于表的总行数。基数的高低影响列的数据分布。
初学者：当查询结果是返回表中5%以内的数据时，应该走索引；当查询结果返回的是超过表中5%的数据时，应该走全表扫描。

选择性（SELECTIVITY）:
基数与总行数的比值再乘以100%就是某个列的选择性。在进行SQL优化的时候，基数必须对比总行数才有实际意义 
当一个列选择性大于20%，说明该列的数据分布就比较均衡了。

什么样的列必须要创建索引呢？当一个列出现在where条件中，该列没有创建索引并且选择性大于20%，那么该列就必须创建索引，从而提升SQL查询性能。
当然了，如果表只有几百条数据，那我们就不用创建索引了。

字节（Bytes）：执行该步骤后返回的字节数
耗费（COST）、CPU 耗费：Oracle 估计的该步骤的执行成本，用于说明 SQL 执行的代价，理论上越小越好（该值可能与实际有出入）
时间（Time）：Oracle 估计的当前操作所需的时间：


直方图是用来
帮助CBO在对基数很低、数据分布不均衡的列进行Rows估算的时候，可以得到更精确的Rows就够了。


Oracle最小的存储单位是块(block），物理上连续的块组成了区( extent），区又组成了段（( segment）。
对于非分区表，如果表中没有clob/blob字段，那么一个表就是一个段。
全表扫描，其实就是扫描表中所有格式化过的区。因为区里面的数据块在物理上是连续的，所以全表扫描可以多块读。
全表扫描不能跨区扫描，因为区与区之间的块物理上不一定是连续的。对于分区表，如果表中没有clob/blob字段，一个分区就是一个段，
分区表扫描方式与非分区表扫描方式是一样的。



如果表中有clob字段，clob会单独存放在一个段中，当全表扫描需要访问clob字段时，这时性能会严重下降，因此尽量避免在Oracle中使用clob。
我们可以考虑将clob字段拆分为多个varchar2 ( 4000）字段，或者将clob存放在nosql数据库中，例如mongodb。

一般的操作系统，一次I/O最多只支持读取或者写入1MB数据。数据块为8KB的时候，一次I/O最多能读取128个块。
数据块为16KB的时候，一次I/O最多能读取64个块，数据块为32KB的时候，一次IO最多能读取32个块。



TABLE ACCESS BY USER ROWID表示直接用ROWID获取数据，单块读。
TABLE ACCESS BY ROWID RANGE表示ROWID范围扫描，多块读。
因为同一个块里面的ROWID是连续的，同一个EXTENT里面的ROWID也是连续的，所以可以多块读。
TABLE ACCESS BY INDEX ROWID表表，单块读。
INDEX UNIQUE SCAN表示索引唯一扫描，单块读。
INDEX RANGE SCAN表示索引范围扫描，单块读，返回的数据是有序的（默认升序）。 
INDEX SKIP SCAN表示索引跳跃扫描，单块读。返回的数据是有序的（默认升序）。 
INDEX FULL SCAN表示索引全扫描，单读，返回的数据是有序的（默认升序）。 
INDEX FAST FULL SCAN表示索引快速全扫描，多块读。 
INDEX FULL SCAN（MIN/MAX）表示索引最小/最大值扫描、单块读，
该访问路径发生SELECT MAX（COLUMN）FROM TABLE 或者SELECT MIN（COLUMN）FROM TABLE等SQL语句中。

MAT_VIEW REWRITE ACCESS FULL表示物化视图全表扫描、多块读。因为物化视图本质上也是一个表，所以其扫描方式与全表扫描方式一样。
如果我们开启了查询重写功能，而且SQL查询能够直接从物化视图中获得结果，就会走该访问路径。



从磁盘1次读取1个块到buffer cache就叫单块读，从磁盘1次读取多个块到buffer cache就叫多块读。
如果数据块都已经缓存在buffer cache中，那就不需要物理I/O了，没有物理I/O也就不存在单块读与多块读。

绝大多数的平台，一次I/O最多只能读取或者写入1MB数据，Oracle的块大小默认是8k，那么一次I/O最多只能写入128个块到磁盘，最多只能读取128个块到buffer cache。
在判断哪个访问路径性能好的时候，通常是估算每个访问路径的I/O次数，谁的I/O次数少，谁的性能就好。在估算I/O次数的时候，我们只需要算个大概就可以了，没必要很精确。

索引扫描其实分为两步
1 扫描索引得到对应的 ROWID。
2 通过 ROWID 定位到具体的行读取数据。


